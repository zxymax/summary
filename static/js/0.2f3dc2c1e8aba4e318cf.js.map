{"version":3,"sources":["webpack:///src/components/Page2/VuexCodeSplit.vue","webpack:///./src/components/Page2/VuexCodeSplit.vue?8368","webpack:///./src/components/Page2/VuexCodeSplit.vue"],"names":["Page2_VuexCodeSplit","render","this","$createElement","_self","_c","_m","staticRenderFns","_vm","_h","staticClass","_v","attrs","width","height","src","alt","id","Component","__webpack_require__","normalizeComponent","ssrContext","__webpack_exports__"],"mappings":"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","file":"static/js/0.2f3dc2c1e8aba4e318cf.js","sourcesContent":["<template>\n\t<div>\n\t\t<div class=\"container\">\n\t\t<h1>Vuex学习心得</h1>\n\t\t<div class=\"content\">\n\t\t\t<h2><strong>Vuex概念：</strong> Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</h2>\n\t\t\t\n\t\t\t<h2><strong>什么是状态管理模式？：</strong></h2>\n\t\t\n\t\t\t\t<ul>\n\t\t\t\t\t<li>state,驱动应用的数据源</li>\n\t\t\t\t\t<li>view,以声明方式将state映射到视图</li>\n\t\t\t\t\t<li>actions,响应式在view上的用户输入导致的状态变化</li>\n\t\t\t\t</ul>\n\t\t\t\t<p>以下是一个表示 “单向数据流“理念的极简示意图</p>\n\t\t\t\t<div class=\"image\">\n\t\t\t\t\t<img width=\"300\" height=\"210\" src=\"https://vuex.vuejs.org/zh-cn/images/flow.png\" alt=\"\">\n\t\t\t\t</div>\n\t\t\t<h2>\n\t\t\t\t<span class=\"warning\">注意： 但是，当我们的应用遇到多个组件共享状态时,单项数据流的简洁性很容易破坏：</span>\n\t\t\t\t<ul>\n\t\t\t\t\t<li>问题1:多个视图依赖于同一状态。</li>\n\t\t\t\t\t<li>问题2:来自不同视图的行为需要变更同一状态。</li>\n\t\t\t\t</ul>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t因此我们需要把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，我们组件树构成了一个巨大的”视图“，不管在树的哪个位置，任何组件都能获取状态或者触发行为！\n\t\t\t\t</p>\n\t\t\t\t<p><i>通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。</i></p>\n\t\t\t</h2>\n\t\t\t<div class=\"image\">\n\t\t\t\t<img width=\"671\" height=\"527\" src=\"https://vuex.vuejs.org/zh-cn/images/vuex.png\" alt=\"\">\n\t\t\t</div>\n\t\t\t<h2><strong>什么情况下我应该使用 Vuex？</strong></h2>\n\t\t\t<p>\n\t\t\t\t如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。\n\t\t\t</p>\n\t\t</div>\n\t\t<div class=\"content\">\n\t\t\t<h2><strong>安装Vuex</strong></h2>\n\t\t\t<h3>\n\t\t\t\t<span class=\"code\">\n\t\t\t\t\tnpm install vuex --save\n\t\t\t\t</span>\n\t\t\t\t<span class=\"code\">\n\t\t\t\t\tyarn add vuex\n\t\t\t\t</span>\n\t\t\t</h3>\n\t\t\t<p class=\"bg-success\">\n\t\t\t\t在store/index.js文件中引用vuex文件 并且使用use使用vuex\n\t\t\t</p>\n\t\t\t<h3>\n\t\t\t\t<span class=\"code\">import Vue from 'vue'</span>\n\t\t\t\t<span class=\"code\">import Vuex from 'vuex'</span>\n\t\t\t\t<span class=\"code\">Vue.use(Vuex)</span>\n\t\t\t</h3>\n\n\t\t\t<h2><strong>Vuex核心概念</strong></h2>\n\t\t\t<h5>\n\t\t\t\t<span class=\"info\">State</span>\n\t\t\t\t<span class=\"info\">Getter</span>\n\t\t\t\t<span class=\"info\">Mutation</span>\n\t\t\t\t<span class=\"info\">Action</span>\n\t\t\t\t<span class=\"info\">Module</span>\n\t\t\t</h5>\n\t\t\t<div class=\"section\">\n\t\t\t\t\n\t\t\t\n\t\t\t<h2>\n\t\t\t\t<strong>State</strong>单一状态树，即Vuex中的基本数据。用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。\n\t\t\t</h2>\n\t\t\t<p class=\"bg-success\">\n\t\t\t\t我们可以通过Vue的computed获得Vuex的state，如下：\n\t\t\t</p>\n\t\t\t<div class=\"code\">\n\t\t\t\t<pre>\n\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t    state: {\n\t\t\t\t\t        count:0\n\t\t\t\t\t    }\n\t\t\t\t\t})\n\t\t\t\t\tconst app = new Vue({\n\t\t\t\t\t    //..\n\t\t\t\t\t    store,\n\t\t\t\t\t    computed: {\n\t\t\t\t\t        count: function(){\n\t\t\t\t\t            return this.$store.state.count\n\t\t\t\t\t        }\n\t\t\t\t\t    },\n\t\t\t\t\t    //..\n\t\t\t\t\t})\n\t\t\t\t</pre>\n\t\t\t\t\n\t\t\t</div>\n\t\t\t<p>\n\t\t\t\t\t<span class=\"warning\">每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。</span>\n\t\t\t\t</p>\n\t\t\t\t<h2><strong>mapState辅助函数</strong></h2>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\t// 在单独构建的版本中辅助函数为 Vuex.mapState\n\t\t\t\t\t\timport { mapState } from 'vuex'\n\n\t\t\t\t\t\texport default {\n\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t  computed: mapState({\n\t\t\t\t\t\t    // 箭头函数可使代码更简练\n\t\t\t\t\t\t    count: state => state.count,\n\n\t\t\t\t\t\t    // 传字符串参数 'count' 等同于 `state => state.count`\n\t\t\t\t\t\t    countAlias: 'count',\n\n\t\t\t\t\t\t    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n\t\t\t\t\t\t    countPlusLocalState (state) {\n\t\t\t\t\t\t      return state.count + this.localCount\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t  })\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tcomputed: mapState([\n\t\t\t\t\t\t  // 映射 this.count 为 store.state.count\n\t\t\t\t\t\t  'count'\n\t\t\t\t\t\t])\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<h2><strong>对象扩展运算符</strong></h2>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\tmapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符，我们可以极大地简化写法：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tcomputed: {\n\t\t\t\t\t\t  localComputed () //本地计算属性\n\t\t\t\t\t\t  //使用对象展开运算符将此对象混入到外部对象中\n\t\t\t\t\t\t  ...mapState({\n\t\t\t\t\t\t    //..\n\t\t\t\t\t\t  })\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"section\">\n\t\t\t\t<h2><strong>Getters</strong>即从store的state中派生出的状态。</h2>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\tgetters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t\t    state: {\n\t\t\t\t\t\t        count:0\n\t\t\t\t\t\t    }，\n\t\t\t\t\t\t    getters: {\n\t\t\t\t\t\t        // 单个参数\n\t\t\t\t\t\t        countDouble: function(state){\n\t\t\t\t\t\t            return state.count * 2\n\t\t\t\t\t\t        },\n\t\t\t\t\t\t        // 两个参数\n\t\t\t\t\t\t        countDoubleAndDouble: function(state, getters) {\n\t\t\t\t\t\t            return getters.countDouble * 2\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t与state一样，我们也可以通过Vue的Computed获得Vuex的getters。\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tconst app = new Vue({\n\t\t\t\t\t\t    //..\n\t\t\t\t\t\t    store,\n\t\t\t\t\t\t    computed: {\n\t\t\t\t\t\t        count: function(){\n\t\t\t\t\t\t            return this.$store.state.count\n\t\t\t\t\t\t        },\n\t\t\t\t\t\t        countDouble: function(){\n\t\t\t\t\t\t            return this.$store.getters.countDouble\n\t\t\t\t\t\t        },\n\t\t\t\t\t\t        countDoubleAndDouble: function(){\n\t\t\t\t\t\t            return this.$store.getters.countDoubleAndDouble\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t    },\n\t\t\t\t\t\t    //..\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<h2>\n\t\t\t\t\t<strong>mapGetters 辅助函数</strong>\n\t\t\t\t</h2>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\tmapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性，与state类似\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\timport { mapGetters } from 'vuex'\n\t\t\t\t\t\texport default {\n\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t  computed: {\n\t\t\t\t\t\t  // 使用对象展开运算符将 getters 混入 computed 对象中\n\t\t\t\t\t\t    ...mapGetters([\n\t\t\t\t\t\t      'countDouble',\n\t\t\t\t\t\t      'CountDoubleAndDouble',\n\t\t\t\t\t\t      //..\n\t\t\t\t\t\t    ])\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t如果你想将一个 getter 属性另取一个名字，使用对象形式：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tmapGetters({\n\t\t\t\t\t\t  // 映射 this.double 为 store.getters.countDouble\n\t\t\t\t\t\t  double: 'countDouble'\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"section\">\n\t\t\t\t<h2><strong>Mutations</strong>提交mutation是更改Vuex中的store中的状态的唯一方法。</h2>\n\t\t\t\t<p><span class=\"warning\">mutation必须是同步的，如果要异步需要使用action。\n\t\t\t\t</span></p>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数,提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t\t  state: {\n\t\t\t\t\t\t    count: 1\n\t\t\t\t\t\t  },\n\t\t\t\t\t\t  mutations: {\n\t\t\t\t\t\t    //无提交荷载\n\t\t\t\t\t\t    increment(state) {\n\t\t\t\t\t\t        state.count++\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    //提交荷载\n\t\t\t\t\t\t    increment(state, obj) {\n\t\t\t\t\t\t      state.count += obj.n\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p><span class=\"warning\">\n\t\t\t\t\t你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：\n\t\t\t\t</span></p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\t//无提交荷载\n\t\t\t\t\t\tstore.commit('increment')\n\t\t\t\t\t\t//提交荷载\n\t\t\t\t\t\tstore.commit('increment', {\n\t\t\t\t\t\t    n: 100\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p><span class=\"warning\">\n\t\t\t\t\t在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：\n\t\t\t\t</span></p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\t// ...\n\t\t\t\t\t\tstore.commit({\n\t\t\t\t\t\t  type: 'increment',\n\t\t\t\t\t\t  n: 10\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p><span class=\"warning\">\n\t\t\t\t\t当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：\n\t\t\t\t</span></p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tmutations: {\n\t\t\t\t\t\t  increment (state, payload) {\n\t\t\t\t\t\t    state.count += payload.amount\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t<b>使用常量替代 Mutation 事件类型</b>\n\n\t\t\t\t</p>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\t// mutation-types.js\n\t\t\t\t\t\texport const SOME_MUTATION = 'SOME_MUTATION'\n\t\t\t\t\t\t// store.js\n\t\t\t\t\t\timport Vuex from 'vuex'\n\t\t\t\t\t\timport { SOME_MUTATION } from './mutation-types'\n\n\t\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t\t  state: { ... },\n\t\t\t\t\t\t  mutations: {\n\t\t\t\t\t\t    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n\t\t\t\t\t\t    [SOME_MUTATION] (state) {\n\t\t\t\t\t\t      // mutate state\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<h2><strong>在组件中提交 Mutation</strong></h2>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t你可以在组件中使用 this.$store.commit('xxx') 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\timport { mapMutations } from 'vuex'\n\n\t\t\t\t\t\texport default {\n\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t  methods: {\n\t\t\t\t\t\t    ...mapMutations([\n\t\t\t\t\t\t      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n\t\t\t\t\t\t      // `mapMutations` 也支持载荷：\n\t\t\t\t\t\t      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n\t\t\t\t\t\t    ]),\n\t\t\t\t\t\t    ...mapMutations({\n\t\t\t\t\t\t      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n\t\t\t\t\t\t    })\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"section\">\n\t\t\t\t<h2><strong>Action</strong>Action 类似于 mutation，不同在于：</h2>\n\t\t\t\t<ul>\n\t\t\t\t\t<li><span class=\"warning\">Action 提交的是 mutation，而不是直接变更状态。</span></li>\n\t\t\t\t\t<li><span class=\"warning\">Action 可以包含任意异步操作。</span></li>\n\t\t\t\t</ul>\n\t\t\t\t<h3>\n\t\t\t\t\t让我们来注册一个简单的 action：\n\t\t\t\t</h3>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t\t  state: {\n\t\t\t\t\t\t    count: 0\n\t\t\t\t\t\t  },\n\t\t\t\t\t\t  mutations: {\n\t\t\t\t\t\t    increment (state) {\n\t\t\t\t\t\t      state.count++\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t  },\n\t\t\t\t\t\t  actions: {\n\t\t\t\t\t\t    increment (context) {\n\t\t\t\t\t\t      context.commit('increment')\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\tAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n\t\t\t\t</p>\n\t\t\t\t<h2>分发actions</h2>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\tAction 通过 store.dispatch 方法触发：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tstore.dispatch('increment')\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<h2>\n\t\t\t\t\t<strong>其他与mutations类似的地方</strong>\n\t\t\t\t</h2>\n\t\t\t\t<p><span class=\"warning\">\n\t\t\t\t\tActions 支持同样的载荷方式和对象方式进行分发：\n\t\t\t\t</span></p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\t// 以载荷形式分发\n\t\t\t\t\t\tstore.dispatch('increment', {\n\t\t\t\t\t\t  n: 10\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\t// 以对象形式分发\n\t\t\t\t\t\tstore.dispatch({\n\t\t\t\t\t\t  type: 'increment',\n\t\t\t\t\t\t  n: 10\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tactions: {\n\t\t\t\t\t\t  checkout ({ commit, state }, products) {\n\t\t\t\t\t\t    // 把当前购物车的物品备份起来\n\t\t\t\t\t\t    const savedCartItems = [...state.cart.added]\n\t\t\t\t\t\t    // 发出结账请求，然后乐观地清空购物车\n\t\t\t\t\t\t    commit(types.CHECKOUT_REQUEST)\n\t\t\t\t\t\t    // 购物 API 接受一个成功回调和一个失败回调\n\t\t\t\t\t\t    shop.buyProducts(\n\t\t\t\t\t\t      products,\n\t\t\t\t\t\t      // 成功操作\n\t\t\t\t\t\t      () => commit(types.CHECKOUT_SUCCESS),\n\t\t\t\t\t\t      // 失败操作\n\t\t\t\t\t\t      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n\t\t\t\t\t\t    )\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p><span class=\"warning\">\n\t\t\t\t\t注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。\n\t\t\t\t</span></p>\n\t\t\t\t<h2><strong>在组件中分发 Action</strong></h2>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\timport { mapActions } from 'vuex'\n\n\t\t\t\t\t\texport default {\n\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t  methods: {\n\t\t\t\t\t\t    ...mapActions([\n\t\t\t\t\t\t      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n\t\t\t\t\t\t      // `mapActions` 也支持载荷：\n\t\t\t\t\t\t      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n\t\t\t\t\t\t    ]),\n\t\t\t\t\t\t    ...mapActions({\n\t\t\t\t\t\t      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n\t\t\t\t\t\t    })\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<h2><strong>\n\t\t\t\t\t组合 Action\n\t\t\t\t</strong></h2>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\tAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n\t\t\t\t</p>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tactions: {\n\t\t\t\t\t\t  actionA ({ commit }) {\n\t\t\t\t\t\t    return new Promise((resolve, reject) => {\n\t\t\t\t\t\t      setTimeout(() => {\n\t\t\t\t\t\t        commit('someMutation')\n\t\t\t\t\t\t        resolve()\n\t\t\t\t\t\t      }, 1000)\n\t\t\t\t\t\t    })\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<h2><strong>现在你可以：</strong></h2>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tstore.dispatch('actionA').then(() => {\n\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t})\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<h2><strong>\n\t\t\t\t\t在另外一个 action 中也可以：\n\t\t\t\t</strong></h2>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tactions: {\n\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t  actionB ({ dispatch, commit }) {\n\t\t\t\t\t\t    return dispatch('actionA').then(() => {\n\t\t\t\t\t\t      commit('someOtherMutation')\n\t\t\t\t\t\t    })\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t最后，如果我们利用 async / await，我们可以如下组合 action：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\t// 假设 getData() 和 getOtherData() 返回的是 Promise\n\n\t\t\t\t\t\tactions: {\n\t\t\t\t\t\t  async actionA ({ commit }) {\n\t\t\t\t\t\t    commit('gotData', await getData())\n\t\t\t\t\t\t  },\n\t\t\t\t\t\t  async actionB ({ dispatch, commit }) {\n\t\t\t\t\t\t    await dispatch('actionA') // 等待 actionA 完成\n\t\t\t\t\t\t    commit('gotOtherData', await getOtherData())\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<h2><span class=\"warning\">\n\t\t\t\t\t一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\n\t\t\t\t</span></h2>\n\t\t\t</div>\n\n\t\t\t<div class=\"section\">\n\t\t\t\t<h2><strong>\n\t\t\t\t\tModule\n\t\t\t\t</strong></h2>\n\t\t\t\t<p>\n\t\t\t\t\t由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\t\t\t\t</p>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tconst moduleA = {\n\t\t\t\t\t\t  state: { ... },\n\t\t\t\t\t\t  mutations: { ... },\n\t\t\t\t\t\t  actions: { ... },\n\t\t\t\t\t\t  getters: { ... }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst moduleB = {\n\t\t\t\t\t\t  state: { ... },\n\t\t\t\t\t\t  mutations: { ... },\n\t\t\t\t\t\t  actions: { ... }\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t\t  modules: {\n\t\t\t\t\t\t    a: moduleA,\n\t\t\t\t\t\t    b: moduleB\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tstore.state.a // -> moduleA 的状态\n\t\t\t\t\t\tstore.state.b // -> moduleB 的状态\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<h2>\n\t\t\t\t\t<strong>模块的局部状态</strong>\n\t\t\t\t</h2>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tconst moduleA = {\n\t\t\t\t\t\t  state: { count: 0 },\n\t\t\t\t\t\t  mutations: {\n\t\t\t\t\t\t    increment (state) {\n\t\t\t\t\t\t      // 这里的 `state` 对象是模块的局部状态\n\t\t\t\t\t\t      state.count++\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t  },\n\n\t\t\t\t\t\t  getters: {\n\t\t\t\t\t\t    doubleCount (state) {\n\t\t\t\t\t\t      return state.count * 2\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tconst moduleA = {\n\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t  actions: {\n\t\t\t\t\t\t    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n\t\t\t\t\t\t      if ((state.count + rootState.count) % 2 === 1) {\n\t\t\t\t\t\t        commit('increment')\n\t\t\t\t\t\t      }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t\t<p class=\"bg-success\">\n\t\t\t\t\t对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\n\t\t\t\t</p>\n\t\t\t\t<div class=\"code\">\n\t\t\t\t\t<pre>\n\t\t\t\t\t\tconst moduleA = {\n\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t  getters: {\n\t\t\t\t\t\t    sumWithRootCount (state, getters, rootState) {\n\t\t\t\t\t\t      return state.count + rootState.count\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t</pre>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\n\t\t</div>\n\t\t<div class=\"content\">\n\t\t\t<h2><strong>项目结构</strong></h2>\n\t\t\t<p class=\"bg-success\">\n\t\t\t\tVuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：\n\t\t\t</p>\n\t\t\t<ul>\n\t\t\t\t<li>应用层级的状态应该集中到单个 store 对象中。</li>\n\t\t\t\t<li>提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。</li>\n\t\t\t\t<li>异步逻辑都应该封装到 action 里面。</li>\n\t\t\t</ul>\n\t\t\t<p><span class=\"warning\">\n\t\t\t\t只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n\t\t\t</span></p>\n\t\t\t<p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p>\n\t\t\t<div class=\"code\">\n\t\t\t\t<pre>\n\t\t\t\t\t├── index.html\n\t\t\t\t\t├── main.js\n\t\t\t\t\t├── api\n\t\t\t\t\t│   └── ... # 抽取出API请求\n\t\t\t\t\t├── components\n\t\t\t\t\t│   ├── App.vue\n\t\t\t\t\t│   └── ...\n\t\t\t\t\t└── store\n\t\t\t\t\t    ├── index.js          # 我们组装模块并导出 store 的地方\n\t\t\t\t\t    ├── actions.js        # 根级别的 action\n\t\t\t\t\t    ├── mutations.js      # 根级别的 mutation\n\t\t\t\t\t    └── modules\n\t\t\t\t\t        ├── cart.js       # 购物车模块\n\t\t\t\t\t        └── products.js   # 产品模块\n\t\t\t\t</pre>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div class=\"container\">\n\t\t<h1>路由懒加载</h1>\n\t\t<div class=\"content\">\n\t\t\t<p class=\"bg-success\">\n\t\t\t\t当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。\n\t\t\t</p>\n\t\t\t<p><span class=\"warning\">\n\t\t\t\t结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。\n\t\t\t</span></p>\n\n\t\t\t<p class=\"bg-success\">\n\t\t\t\t首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：\n\t\t\t</p>\n\t\t\t<div class=\"code\">\n\t\t\t\t<pre>\n\t\t\t\t\tconst Foo = () => Promise.resolve({ /* 组件定义对象 */ })\n\t\t\t\t</pre>\n\t\t\t</div>\n\t\t\t<p class=\"bg-success\">\n\t\t\t\t第二，在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)：\n\t\t\t</p>\n\t\t\t<div class=\"code\">\n\t\t\t\t<pre>\n\t\t\t\t\timport('./Foo.vue') // 返回 Promise\n\t\t\t\t</pre>\n\t\t\t</div>\n\t\t\t<p><span class=\"warning\">\n\t\t\t\t注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。\n\t\t\t</span></p>\n\t\t\t<p>\n\t\t\t\t结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。\n\t\t\t</p>\n\t\t\t<div class=\"code\">\n\t\t\t\t<pre>\n\t\t\t\t\tconst Foo = () => import('./Foo.vue')\n\t\t\t\t</pre>\n\t\t\t</div>\n\t\t\t<p>\n\t\t\t\t在路由配置中什么都不需要改变，只需要像往常一样使用 Foo：\n\t\t\t</p>\n\t\t\t<div class=\"code\">\n\t\t\t\t<pre>\n\t\t\t\t\tconst router = new VueRouter({\n\t\t\t\t\t  routes: [\n\t\t\t\t\t    { path: '/foo', component: Foo }\n\t\t\t\t\t  ]\n\t\t\t\t\t})\n\t\t\t\t</pre>\n\t\t\t</div>\n\t\t\t<h2><strong>把组件按组分块</strong></h2>\n\t\t\t<p class=\"bg-success\">\n\t\t\t\t有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)。\n\t\t\t</p>\n\t\t\t<div class=\"code\">\n\t\t\t\t<pre>\n\t\t\t\t\tconst Foo = () => import(/* webpackChunkName: \"group-foo\" */ './Foo.vue')\n\t\t\t\t\tconst Bar = () => import(/* webpackChunkName: \"group-foo\" */ './Bar.vue')\n\t\t\t\t\tconst Baz = () => import(/* webpackChunkName: \"group-foo\" */ './Baz.vue')\n\t\t\t\t</pre>\n\t\t\t</div>\n\t\t\t<p><span class=\"warning\">\n\t\t\t\tWebpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。\n\t\t\t</span></p>\n\t\t</div>\n\t</div>\n\t<div class=\"container\">\n\t\t<div class=\"content\">\n\t\t\t<div id=\"createul\">\n\t\t\t\t\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t</div>\n</template>\n<script>\n\texport default{\n\t\t\n\t}\n</script>\n<style scoped>\n\t<style>\n\t\tbody{\n\t\t\tcolor: #999;\n\t\t}\n\t\t.container{\n\t\t\tborder: 1px solid #f0f;\n\t\t\tpadding: 10px;\n\t\t\tmargin: 10px;\n\t\t}\n\t\th1{\n\t\t\tfont-weight: bold;\n\t\t\ttext-decoration: underline;\n\t\t}\n\t\t.content{\n\t\t\tborder: 1px solid #ef0;\n\t\t\tpadding: 10px;\n\t\t\tmargin: 10px;\n\t\t}\n\t\t.section{\n\t\t\tmargin: 15px;\n\t\t\tpadding: 10px;\n\t\t\tborder: 2px solid #fbb390;\n\t\t}\n\n\t\th2 strong{\n\t\t\tbackground-color: #888;\n\t\t\tcolor: #fff;\n\t\t\tfont-size: 16px;\n\t\t\tpadding: 5px;\n\t\t}\n\t\t.image{\n\t\t\tpadding: 10px;\n\t\t\tborder: 1px solid #e9f;\n\t\t}\n\t\t span.warning{\n\t\t\tbackground-color: #e90;\n\t\t\tcolor: #fff;\n\t\t}\n\t\tp.bg-success{\n\t\t\tbackground-color: #dff0d8;\n\t\t\tcolor: #333;\n\t\t}\n\t\t\n\t\tdiv.code{\n\t\t\tpadding: 10px;\n\t\t}\n\t\tul{\n\t\t\tline-height: 1.5;\n\t\t}\n\t</style>\n</style>\n\n\n// WEBPACK FOOTER //\n// src/components/Page2/VuexCodeSplit.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:\"container\"},[_c('h1',[_vm._v(\"Vuex学习心得\")]),_vm._v(\" \"),_c('div',{staticClass:\"content\"},[_c('h2',[_c('strong',[_vm._v(\"Vuex概念：\")]),_vm._v(\" Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\")]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"什么是状态管理模式？：\")])]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"state,驱动应用的数据源\")]),_vm._v(\" \"),_c('li',[_vm._v(\"view,以声明方式将state映射到视图\")]),_vm._v(\" \"),_c('li',[_vm._v(\"actions,响应式在view上的用户输入导致的状态变化\")])]),_vm._v(\" \"),_c('p',[_vm._v(\"以下是一个表示 “单向数据流“理念的极简示意图\")]),_vm._v(\" \"),_c('div',{staticClass:\"image\"},[_c('img',{attrs:{\"width\":\"300\",\"height\":\"210\",\"src\":\"https://vuex.vuejs.org/zh-cn/images/flow.png\",\"alt\":\"\"}})]),_vm._v(\" \"),_c('h2',[_c('span',{staticClass:\"warning\"},[_vm._v(\"注意： 但是，当我们的应用遇到多个组件共享状态时,单项数据流的简洁性很容易破坏：\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"问题1:多个视图依赖于同一状态。\")]),_vm._v(\" \"),_c('li',[_vm._v(\"问题2:来自不同视图的行为需要变更同一状态。\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t因此我们需要把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，我们组件树构成了一个巨大的”视图“，不管在树的哪个位置，任何组件都能获取状态或者触发行为！\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('p',[_c('i',[_vm._v(\"通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。\")])])]),_vm._v(\" \"),_c('div',{staticClass:\"image\"},[_c('img',{attrs:{\"width\":\"671\",\"height\":\"527\",\"src\":\"https://vuex.vuejs.org/zh-cn/images/vuex.png\",\"alt\":\"\"}})]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"什么情况下我应该使用 Vuex？\")])]),_vm._v(\" \"),_c('p',[_vm._v(\"\\n\\t\\t\\t如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。\\n\\t\\t\")])]),_vm._v(\" \"),_c('div',{staticClass:\"content\"},[_c('h2',[_c('strong',[_vm._v(\"安装Vuex\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"code\"},[_vm._v(\"\\n\\t\\t\\t\\tnpm install vuex --save\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('span',{staticClass:\"code\"},[_vm._v(\"\\n\\t\\t\\t\\tyarn add vuex\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t在store/index.js文件中引用vuex文件 并且使用use使用vuex\\n\\t\\t\")]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"code\"},[_vm._v(\"import Vue from 'vue'\")]),_vm._v(\" \"),_c('span',{staticClass:\"code\"},[_vm._v(\"import Vuex from 'vuex'\")]),_vm._v(\" \"),_c('span',{staticClass:\"code\"},[_vm._v(\"Vue.use(Vuex)\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"Vuex核心概念\")])]),_vm._v(\" \"),_c('h5',[_c('span',{staticClass:\"info\"},[_vm._v(\"State\")]),_vm._v(\" \"),_c('span',{staticClass:\"info\"},[_vm._v(\"Getter\")]),_vm._v(\" \"),_c('span',{staticClass:\"info\"},[_vm._v(\"Mutation\")]),_vm._v(\" \"),_c('span',{staticClass:\"info\"},[_vm._v(\"Action\")]),_vm._v(\" \"),_c('span',{staticClass:\"info\"},[_vm._v(\"Module\")])]),_vm._v(\" \"),_c('div',{staticClass:\"section\"},[_c('h2',[_c('strong',[_vm._v(\"State\")]),_vm._v(\"单一状态树，即Vuex中的基本数据。用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。\\n\\t\\t\")]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t我们可以通过Vue的computed获得Vuex的state，如下：\\n\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\tconst store = new Vuex.Store({\\n\\t\\t\\t\\t    state: {\\n\\t\\t\\t\\t        count:0\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\tconst app = new Vue({\\n\\t\\t\\t\\t    //..\\n\\t\\t\\t\\t    store,\\n\\t\\t\\t\\t    computed: {\\n\\t\\t\\t\\t        count: function(){\\n\\t\\t\\t\\t            return this.$store.state.count\\n\\t\\t\\t\\t        }\\n\\t\\t\\t\\t    },\\n\\t\\t\\t\\t    //..\\n\\t\\t\\t\\t})\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"mapState辅助函数\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\t// 在单独构建的版本中辅助函数为 Vuex.mapState\\n\\t\\t\\t\\t\\timport { mapState } from 'vuex'\\n\\n\\t\\t\\t\\t\\texport default {\\n\\t\\t\\t\\t\\t  // ...\\n\\t\\t\\t\\t\\t  computed: mapState({\\n\\t\\t\\t\\t\\t    // 箭头函数可使代码更简练\\n\\t\\t\\t\\t\\t    count: state => state.count,\\n\\n\\t\\t\\t\\t\\t    // 传字符串参数 'count' 等同于 `state => state.count`\\n\\t\\t\\t\\t\\t    countAlias: 'count',\\n\\n\\t\\t\\t\\t\\t    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\\n\\t\\t\\t\\t\\t    countPlusLocalState (state) {\\n\\t\\t\\t\\t\\t      return state.count + this.localCount\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t  })\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tcomputed: mapState([\\n\\t\\t\\t\\t\\t  // 映射 this.count 为 store.state.count\\n\\t\\t\\t\\t\\t  'count'\\n\\t\\t\\t\\t\\t])\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"对象扩展运算符\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\tmapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符，我们可以极大地简化写法：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tcomputed: {\\n\\t\\t\\t\\t\\t  localComputed () //本地计算属性\\n\\t\\t\\t\\t\\t  //使用对象展开运算符将此对象混入到外部对象中\\n\\t\\t\\t\\t\\t  ...mapState({\\n\\t\\t\\t\\t\\t    //..\\n\\t\\t\\t\\t\\t  })\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])])]),_vm._v(\" \"),_c('div',{staticClass:\"section\"},[_c('h2',[_c('strong',[_vm._v(\"Getters\")]),_vm._v(\"即从store的state中派生出的状态。\")]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\tgetters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tconst store = new Vuex.Store({\\n\\t\\t\\t\\t\\t    state: {\\n\\t\\t\\t\\t\\t        count:0\\n\\t\\t\\t\\t\\t    }，\\n\\t\\t\\t\\t\\t    getters: {\\n\\t\\t\\t\\t\\t        // 单个参数\\n\\t\\t\\t\\t\\t        countDouble: function(state){\\n\\t\\t\\t\\t\\t            return state.count * 2\\n\\t\\t\\t\\t\\t        },\\n\\t\\t\\t\\t\\t        // 两个参数\\n\\t\\t\\t\\t\\t        countDoubleAndDouble: function(state, getters) {\\n\\t\\t\\t\\t\\t            return getters.countDouble * 2\\n\\t\\t\\t\\t\\t        }\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t与state一样，我们也可以通过Vue的Computed获得Vuex的getters。\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tconst app = new Vue({\\n\\t\\t\\t\\t\\t    //..\\n\\t\\t\\t\\t\\t    store,\\n\\t\\t\\t\\t\\t    computed: {\\n\\t\\t\\t\\t\\t        count: function(){\\n\\t\\t\\t\\t\\t            return this.$store.state.count\\n\\t\\t\\t\\t\\t        },\\n\\t\\t\\t\\t\\t        countDouble: function(){\\n\\t\\t\\t\\t\\t            return this.$store.getters.countDouble\\n\\t\\t\\t\\t\\t        },\\n\\t\\t\\t\\t\\t        countDoubleAndDouble: function(){\\n\\t\\t\\t\\t\\t            return this.$store.getters.countDoubleAndDouble\\n\\t\\t\\t\\t\\t        }\\n\\t\\t\\t\\t\\t    },\\n\\t\\t\\t\\t\\t    //..\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"mapGetters 辅助函数\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\tmapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性，与state类似\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\timport { mapGetters } from 'vuex'\\n\\t\\t\\t\\t\\texport default {\\n\\t\\t\\t\\t\\t  // ...\\n\\t\\t\\t\\t\\t  computed: {\\n\\t\\t\\t\\t\\t  // 使用对象展开运算符将 getters 混入 computed 对象中\\n\\t\\t\\t\\t\\t    ...mapGetters([\\n\\t\\t\\t\\t\\t      'countDouble',\\n\\t\\t\\t\\t\\t      'CountDoubleAndDouble',\\n\\t\\t\\t\\t\\t      //..\\n\\t\\t\\t\\t\\t    ])\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t如果你想将一个 getter 属性另取一个名字，使用对象形式：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tmapGetters({\\n\\t\\t\\t\\t\\t  // 映射 this.double 为 store.getters.countDouble\\n\\t\\t\\t\\t\\t  double: 'countDouble'\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])])]),_vm._v(\" \"),_c('div',{staticClass:\"section\"},[_c('h2',[_c('strong',[_vm._v(\"Mutations\")]),_vm._v(\"提交mutation是更改Vuex中的store中的状态的唯一方法。\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"mutation必须是同步的，如果要异步需要使用action。\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数,提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tconst store = new Vuex.Store({\\n\\t\\t\\t\\t\\t  state: {\\n\\t\\t\\t\\t\\t    count: 1\\n\\t\\t\\t\\t\\t  },\\n\\t\\t\\t\\t\\t  mutations: {\\n\\t\\t\\t\\t\\t    //无提交荷载\\n\\t\\t\\t\\t\\t    increment(state) {\\n\\t\\t\\t\\t\\t        state.count++\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t    //提交荷载\\n\\t\\t\\t\\t\\t    increment(state, obj) {\\n\\t\\t\\t\\t\\t      state.count += obj.n\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\t\\t你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\t//无提交荷载\\n\\t\\t\\t\\t\\tstore.commit('increment')\\n\\t\\t\\t\\t\\t//提交荷载\\n\\t\\t\\t\\t\\tstore.commit('increment', {\\n\\t\\t\\t\\t\\t    n: 100\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\t\\t在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\t// ...\\n\\t\\t\\t\\t\\tstore.commit({\\n\\t\\t\\t\\t\\t  type: 'increment',\\n\\t\\t\\t\\t\\t  n: 10\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\t\\t当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tmutations: {\\n\\t\\t\\t\\t\\t  increment (state, payload) {\\n\\t\\t\\t\\t\\t    state.count += payload.amount\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_c('b',[_vm._v(\"使用常量替代 Mutation 事件类型\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\t// mutation-types.js\\n\\t\\t\\t\\t\\texport const SOME_MUTATION = 'SOME_MUTATION'\\n\\t\\t\\t\\t\\t// store.js\\n\\t\\t\\t\\t\\timport Vuex from 'vuex'\\n\\t\\t\\t\\t\\timport { SOME_MUTATION } from './mutation-types'\\n\\n\\t\\t\\t\\t\\tconst store = new Vuex.Store({\\n\\t\\t\\t\\t\\t  state: { ... },\\n\\t\\t\\t\\t\\t  mutations: {\\n\\t\\t\\t\\t\\t    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\\n\\t\\t\\t\\t\\t    [SOME_MUTATION] (state) {\\n\\t\\t\\t\\t\\t      // mutate state\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"在组件中提交 Mutation\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t你可以在组件中使用 this.$store.commit('xxx') 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\timport { mapMutations } from 'vuex'\\n\\n\\t\\t\\t\\t\\texport default {\\n\\t\\t\\t\\t\\t  // ...\\n\\t\\t\\t\\t\\t  methods: {\\n\\t\\t\\t\\t\\t    ...mapMutations([\\n\\t\\t\\t\\t\\t      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\\n\\n\\t\\t\\t\\t\\t      // `mapMutations` 也支持载荷：\\n\\t\\t\\t\\t\\t      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\\n\\t\\t\\t\\t\\t    ]),\\n\\t\\t\\t\\t\\t    ...mapMutations({\\n\\t\\t\\t\\t\\t      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\\n\\t\\t\\t\\t\\t    })\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])])]),_vm._v(\" \"),_c('div',{staticClass:\"section\"},[_c('h2',[_c('strong',[_vm._v(\"Action\")]),_vm._v(\"Action 类似于 mutation，不同在于：\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('span',{staticClass:\"warning\"},[_vm._v(\"Action 提交的是 mutation，而不是直接变更状态。\")])]),_vm._v(\" \"),_c('li',[_c('span',{staticClass:\"warning\"},[_vm._v(\"Action 可以包含任意异步操作。\")])])]),_vm._v(\" \"),_c('h3',[_vm._v(\"\\n\\t\\t\\t\\t让我们来注册一个简单的 action：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tconst store = new Vuex.Store({\\n\\t\\t\\t\\t\\t  state: {\\n\\t\\t\\t\\t\\t    count: 0\\n\\t\\t\\t\\t\\t  },\\n\\t\\t\\t\\t\\t  mutations: {\\n\\t\\t\\t\\t\\t    increment (state) {\\n\\t\\t\\t\\t\\t      state.count++\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t  },\\n\\t\\t\\t\\t\\t  actions: {\\n\\t\\t\\t\\t\\t    increment (context) {\\n\\t\\t\\t\\t\\t      context.commit('increment')\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\tAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('h2',[_vm._v(\"分发actions\")]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\tAction 通过 store.dispatch 方法触发：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tstore.dispatch('increment')\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"其他与mutations类似的地方\")])]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\t\\tActions 支持同样的载荷方式和对象方式进行分发：\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\t// 以载荷形式分发\\n\\t\\t\\t\\t\\tstore.dispatch('increment', {\\n\\t\\t\\t\\t\\t  n: 10\\n\\t\\t\\t\\t\\t})\\n\\n\\t\\t\\t\\t\\t// 以对象形式分发\\n\\t\\t\\t\\t\\tstore.dispatch({\\n\\t\\t\\t\\t\\t  type: 'increment',\\n\\t\\t\\t\\t\\t  n: 10\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tactions: {\\n\\t\\t\\t\\t\\t  checkout ({ commit, state }, products) {\\n\\t\\t\\t\\t\\t    // 把当前购物车的物品备份起来\\n\\t\\t\\t\\t\\t    const savedCartItems = [...state.cart.added]\\n\\t\\t\\t\\t\\t    // 发出结账请求，然后乐观地清空购物车\\n\\t\\t\\t\\t\\t    commit(types.CHECKOUT_REQUEST)\\n\\t\\t\\t\\t\\t    // 购物 API 接受一个成功回调和一个失败回调\\n\\t\\t\\t\\t\\t    shop.buyProducts(\\n\\t\\t\\t\\t\\t      products,\\n\\t\\t\\t\\t\\t      // 成功操作\\n\\t\\t\\t\\t\\t      () => commit(types.CHECKOUT_SUCCESS),\\n\\t\\t\\t\\t\\t      // 失败操作\\n\\t\\t\\t\\t\\t      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\\n\\t\\t\\t\\t\\t    )\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\t\\t注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"在组件中分发 Action\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\timport { mapActions } from 'vuex'\\n\\n\\t\\t\\t\\t\\texport default {\\n\\t\\t\\t\\t\\t  // ...\\n\\t\\t\\t\\t\\t  methods: {\\n\\t\\t\\t\\t\\t    ...mapActions([\\n\\t\\t\\t\\t\\t      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\\n\\n\\t\\t\\t\\t\\t      // `mapActions` 也支持载荷：\\n\\t\\t\\t\\t\\t      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\\n\\t\\t\\t\\t\\t    ]),\\n\\t\\t\\t\\t\\t    ...mapActions({\\n\\t\\t\\t\\t\\t      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\\n\\t\\t\\t\\t\\t    })\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"\\n\\t\\t\\t\\t组合 Action\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\tAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tactions: {\\n\\t\\t\\t\\t\\t  actionA ({ commit }) {\\n\\t\\t\\t\\t\\t    return new Promise((resolve, reject) => {\\n\\t\\t\\t\\t\\t      setTimeout(() => {\\n\\t\\t\\t\\t\\t        commit('someMutation')\\n\\t\\t\\t\\t\\t        resolve()\\n\\t\\t\\t\\t\\t      }, 1000)\\n\\t\\t\\t\\t\\t    })\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"现在你可以：\")])]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tstore.dispatch('actionA').then(() => {\\n\\t\\t\\t\\t\\t  // ...\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"\\n\\t\\t\\t\\t在另外一个 action 中也可以：\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tactions: {\\n\\t\\t\\t\\t\\t  // ...\\n\\t\\t\\t\\t\\t  actionB ({ dispatch, commit }) {\\n\\t\\t\\t\\t\\t    return dispatch('actionA').then(() => {\\n\\t\\t\\t\\t\\t      commit('someOtherMutation')\\n\\t\\t\\t\\t\\t    })\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t最后，如果我们利用 async / await，我们可以如下组合 action：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\t// 假设 getData() 和 getOtherData() 返回的是 Promise\\n\\n\\t\\t\\t\\t\\tactions: {\\n\\t\\t\\t\\t\\t  async actionA ({ commit }) {\\n\\t\\t\\t\\t\\t    commit('gotData', await getData())\\n\\t\\t\\t\\t\\t  },\\n\\t\\t\\t\\t\\t  async actionB ({ dispatch, commit }) {\\n\\t\\t\\t\\t\\t    await dispatch('actionA') // 等待 actionA 完成\\n\\t\\t\\t\\t\\t    commit('gotOtherData', await getOtherData())\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\t\\t一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\\n\\t\\t\\t\")])])]),_vm._v(\" \"),_c('div',{staticClass:\"section\"},[_c('h2',[_c('strong',[_vm._v(\"\\n\\t\\t\\t\\tModule\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',[_vm._v(\"\\n\\t\\t\\t\\t由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tconst moduleA = {\\n\\t\\t\\t\\t\\t  state: { ... },\\n\\t\\t\\t\\t\\t  mutations: { ... },\\n\\t\\t\\t\\t\\t  actions: { ... },\\n\\t\\t\\t\\t\\t  getters: { ... }\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tconst moduleB = {\\n\\t\\t\\t\\t\\t  state: { ... },\\n\\t\\t\\t\\t\\t  mutations: { ... },\\n\\t\\t\\t\\t\\t  actions: { ... }\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tconst store = new Vuex.Store({\\n\\t\\t\\t\\t\\t  modules: {\\n\\t\\t\\t\\t\\t    a: moduleA,\\n\\t\\t\\t\\t\\t    b: moduleB\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t})\\n\\n\\t\\t\\t\\t\\tstore.state.a // -> moduleA 的状态\\n\\t\\t\\t\\t\\tstore.state.b // -> moduleB 的状态\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"模块的局部状态\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tconst moduleA = {\\n\\t\\t\\t\\t\\t  state: { count: 0 },\\n\\t\\t\\t\\t\\t  mutations: {\\n\\t\\t\\t\\t\\t    increment (state) {\\n\\t\\t\\t\\t\\t      // 这里的 `state` 对象是模块的局部状态\\n\\t\\t\\t\\t\\t      state.count++\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t  },\\n\\n\\t\\t\\t\\t\\t  getters: {\\n\\t\\t\\t\\t\\t    doubleCount (state) {\\n\\t\\t\\t\\t\\t      return state.count * 2\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tconst moduleA = {\\n\\t\\t\\t\\t\\t  // ...\\n\\t\\t\\t\\t\\t  actions: {\\n\\t\\t\\t\\t\\t    incrementIfOddOnRootSum ({ state, commit, rootState }) {\\n\\t\\t\\t\\t\\t      if ((state.count + rootState.count) % 2 === 1) {\\n\\t\\t\\t\\t\\t        commit('increment')\\n\\t\\t\\t\\t\\t      }\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t\\t对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\\n\\t\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t\\tconst moduleA = {\\n\\t\\t\\t\\t\\t  // ...\\n\\t\\t\\t\\t\\t  getters: {\\n\\t\\t\\t\\t\\t    sumWithRootCount (state, getters, rootState) {\\n\\t\\t\\t\\t\\t      return state.count + rootState.count\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\")])])])]),_vm._v(\" \"),_c('div',{staticClass:\"content\"},[_c('h2',[_c('strong',[_vm._v(\"项目结构\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\tVuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：\\n\\t\\t\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"应用层级的状态应该集中到单个 store 对象中。\")]),_vm._v(\" \"),_c('li',[_vm._v(\"提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。\")]),_vm._v(\" \"),_c('li',[_vm._v(\"异步逻辑都应该封装到 action 里面。\")])]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\t只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\\n\\t\\t\")])]),_vm._v(\" \"),_c('p',[_vm._v(\"对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\t├── index.html\\n\\t\\t\\t\\t├── main.js\\n\\t\\t\\t\\t├── api\\n\\t\\t\\t\\t│   └── ... # 抽取出API请求\\n\\t\\t\\t\\t├── components\\n\\t\\t\\t\\t│   ├── App.vue\\n\\t\\t\\t\\t│   └── ...\\n\\t\\t\\t\\t└── store\\n\\t\\t\\t\\t    ├── index.js          # 我们组装模块并导出 store 的地方\\n\\t\\t\\t\\t    ├── actions.js        # 根级别的 action\\n\\t\\t\\t\\t    ├── mutations.js      # 根级别的 mutation\\n\\t\\t\\t\\t    └── modules\\n\\t\\t\\t\\t        ├── cart.js       # 购物车模块\\n\\t\\t\\t\\t        └── products.js   # 产品模块\\n\\t\\t\\t\")])])])]),_vm._v(\" \"),_c('div',{staticClass:\"container\"},[_c('h1',[_vm._v(\"路由懒加载\")]),_vm._v(\" \"),_c('div',{staticClass:\"content\"},[_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。\\n\\t\\t\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\t结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。\\n\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：\\n\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\tconst Foo = () => Promise.resolve({ /* 组件定义对象 */ })\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t第二，在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)：\\n\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\timport('./Foo.vue') // 返回 Promise\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\t注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。\\n\\t\\t\")])]),_vm._v(\" \"),_c('p',[_vm._v(\"\\n\\t\\t\\t结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。\\n\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\tconst Foo = () => import('./Foo.vue')\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',[_vm._v(\"\\n\\t\\t\\t在路由配置中什么都不需要改变，只需要像往常一样使用 Foo：\\n\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\tconst router = new VueRouter({\\n\\t\\t\\t\\t  routes: [\\n\\t\\t\\t\\t    { path: '/foo', component: Foo }\\n\\t\\t\\t\\t  ]\\n\\t\\t\\t\\t})\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('h2',[_c('strong',[_vm._v(\"把组件按组分块\")])]),_vm._v(\" \"),_c('p',{staticClass:\"bg-success\"},[_vm._v(\"\\n\\t\\t\\t有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)。\\n\\t\\t\")]),_vm._v(\" \"),_c('div',{staticClass:\"code\"},[_c('pre',[_vm._v(\"\\t\\t\\t\\tconst Foo = () => import(/* webpackChunkName: \\\"group-foo\\\" */ './Foo.vue')\\n\\t\\t\\t\\tconst Bar = () => import(/* webpackChunkName: \\\"group-foo\\\" */ './Bar.vue')\\n\\t\\t\\t\\tconst Baz = () => import(/* webpackChunkName: \\\"group-foo\\\" */ './Baz.vue')\\n\\t\\t\\t\")])]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"warning\"},[_vm._v(\"\\n\\t\\t\\tWebpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。\\n\\t\\t\")])])])]),_vm._v(\" \"),_c('div',{staticClass:\"container\"},[_c('div',{staticClass:\"content\"},[_c('div',{attrs:{\"id\":\"createul\"}})])])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-b85e46dc\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/Page2/VuexCodeSplit.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-b85e46dc\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./VuexCodeSplit.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./VuexCodeSplit.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./VuexCodeSplit.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-b85e46dc\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./VuexCodeSplit.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-b85e46dc\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Page2/VuexCodeSplit.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}